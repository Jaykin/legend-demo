1、概述：Object-Oriented OO，面向对象的语言有个标志就是都有类的概念。

2、对象属性类型：数据属性 和 访问器属性
          概述：在不支持Object.defineProperty的浏览器中，无法修改 [[Configurable]]和[[Enumerable]]
          2.1、数据属性：
                         [[Configurable]]：表示能否用delete删除属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为true
                         [[Enumerable]]：表示能否通过for-in循环返回属性，默认为true
                         [[Writable]]：表示能否修改属性的值，默认为true
                         [[Value]]：包含这个属性的值，默认为undefined
                         
                         修改：
                              Object.defineProperty(object, propertyName, descriptorObject)：调用这个方法时若不指定描述符对象，则各属性的布尔特性默认为false
          2.2、访问器属性：
                         概述：不包含数据值，包含一对getter和setter函数。其不能直接定义，需要使用Object.defineProperty（）来定义。
                         [[Configurable]]：表示能否用delete删除属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为true
                         [[Enumerable]]：表示能否通过for-in循环返回属性，默认为true
                         [[Get]]：读取属性时调用的函数，默认为undefined
                         [[Set]]：写入属性时调用的函数，默认为undefined
                         非标准方法：
                              object.__defineGetter__(propertyName, function(){})
                              object.__defineSetter__(propertyName, function(){})
          2.3、定义多个属性：
                         概述：Object.defineProperties(object, propertyObject)
          2.4、读取属性的特性：
                         概述：Object.getOwnPropertyDescriptor(object，propertyName)，可以取得给定属性的描述符

3、创建对象：
          概述：使用Object构造函数和字面量形式可以用来创建单个对象。缺点：使用同一接口创建多个对象，会产生大量重复代码
          3.1、工厂模式：这种模式抽象了创建对象的具体过程，JS中用函数来封装以特定接口创建对象的细节。
                         解决：解决创建多个相似对象的问题
                         缺点：创建的对象仅是Object类型，无法设置为自定义的任何类型
          3.2、构造函数模式：
                         解决：构造函数可以用来创建特定类型的对象
                         缺点：每个同样任务的方法都要在每个实例上创建一遍
          3.3、原型模式：
                         概述：每个函数都有prototype属性，其指向一个对象，这个包含由特定类型的所有实例共享的属性和方法
                         原型对象：
                                   1、创建一个新函数的同时，会为该函数创建一个prototype属性，这个属性指向函数的原型对象。
                                   2、默认情况下，所有原型对象都会自动获得一个constructor属性，其指向prototype属性所在的函数，而对象的__proto__对象属性的所有属性继承自上级(Object)的原型对象。
                                   3、虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。
                                   4、检测实例与原型的关系：
                                             
                                   5、检测属性存在实例还是原型上：
                                             object.hasOwnProperty('propertyName')：
                                             in操作符：
                                                       1、for-in结构：遍历实例可访问的可枚举的属性，包括存在原型上的属性
                                                       2、单独in：确定对象能否访问某属性，无论属性是在原型上还是实例上。propertyName in object
                                             
                                   6、获取对象的属性集合：
                                             Object.keys（object）：返回一个包含所有可枚举属性的字符串数组
                                             Object.getOwnPropertyNames（object）：返回所有属性的字符串数组
                                   7、更简单的原型语法：
                                             注意：重写原型对象会导致默认的constructor变化
                                             
                                   8、原型的动态性：
                                             概述：由于在原型中查找值得过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即在实例上反映出来。（即使是先创建了实例再修改原型）
                                                       如果创建实例后重写了原型对象，那此时就切断了构造函数与最初原型之间的联系。实例中的原型指针(__proto__)仅是指向创建该实例时的原型对象
                                             注意：不推荐修改原生对象的原型！
                                             
                         解决：所有实例共享同样任务的方法
                         缺点：
                                   1、没有为构造函数传递参数，导致每个实例没有自己的特性！
                                   2、原型的所有属性都被所有实例共享，导致每个实例都共同拥有这些属性，没有自己的特性！
          3.4、组合使用构造函数和原型模式：
                         概述：是创建自定义类型的常见方式。构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。
                         解决：能自定义共享和不共享的成员
                         注意：原型 和 构造函数是独立定义的
          3.5、动态原型模式：
                         概述：将所有信息都封装在构造函数中，在构造函数中通过检查某个应该存在的方法是否有效来决定是否需要初始化原型。
                         
          3.6、寄生构造函数模式：
                         概述：基本思想是创建一个函数，该函数仅仅是封装创建对象的代码，然后再返回新创建的对象。
                         应用场景：创建一个具有额外方法的特殊数组，但又不直接修改Array构造函数，则可以使用这个模式
                         问题：由此创建的实例与构造函数及其原型没有什么关系！
                         
          3.7、稳妥构造函数模式：
                         稳妥对象：durable object，指的是没有公共属性，而且其方法也不引用this对象。适合在安全的环境中，或者在防止数据被其他应用程序改动时使用
                         概述：
                         
4、继承：
          概述：许多OO语言支持两种继承方式
               1、接口继承：只继承函数签名，JS没有函数签名，故实现不了
               2、实现继承：继承实际的方法，JS主要依靠原型链来实现
          4.1、原型链：
               1、实现JS继承的主要方法，基本思想是：利用原型让一个引用类型继承另一个引用类型的成员
               2、问题1：在通过原型实现继承时，原型其实是另一个类型的实例，那么另一个类型实例所具有的特殊的属性就变成了现在原型的属性了。
               3、问题2：在创建子类型的实例时，不能向超类型的构造函数中传递参数，所以处于对这些问题的考虑，实践中很少会单独使用原型链！
                         
          4.2、借用构造函数：
               基本思想：在子类型构造函数中调用超类型的构造函数。
               传递参数：即能在子类型构造函数中向超类型构造函数传入参数
               问题：在超类型原型中定义的方法，子类型实例访问不了。函数也不可复用！
                         
          4.3、组合继承：
               概述：组合使用原型链 和 借用构造函数技术，是JS最常用的继承模式
               思路：使用原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承
               问题：两次调用了超类型构造函数，且子类型的原型上有无用的属性！
                         
          4.4、原型式继承：
               概述：借助原型，可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。即将一个对象作为新对象的原型
                         ES5提供Object.create(prototype[，instacePropertyObj])来实现！
               应用场景：没必要创建构造函数，而只想让一个对象与另一个对象保持类似的情况
                         
          4.5、寄生式继承：
               概述：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，然后返回对象。
                         
          4.6、寄生组合式继承：
               概述：通过借用构造函数来继承实例属性，通过原型链方式来继承超类型原型的方法。是最理想的继承范式
               思路：即子类型的原型只需要是超类型的一个副本即可，不需要再成为超类型的实例！
                         
              



源码：https://github.com/Jaykin/advanced-js-demo
