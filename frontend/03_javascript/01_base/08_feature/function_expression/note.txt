1、概述：定义函数的方式有两种，一是函数声明，二是函数表达式。
2、函数表达式：
          匿名函数：也称为拉姆达函数
          有名字的函数表达式：
               No1：函数体内不能重写函数名，标准模式下操作会被忽略，严格模式下会报错！
               No2：有名字的函数名在函数作用域内能被访问，但不能重新赋值，而在函数外部是访问不了的（其就是函数作用域内的变量）
               
               参考：
                   http://justjavac.com/named-function-expressions-demystified.htm
3、递归：通过函数名调用自己
          3.1、利用定义的函数名来进行调用实现递归
               
          3.2、利用arguments.callee来实现递归，但是在严格模式下不能使用！！
               
          3.3、利用函数表达式来实现：即可以很好的实现递归，又能在严格模式下使用！（最佳实践）
               
4、函数作用域内变量的优先级：作用域定义的变量 > 形参 > 自身函数名 > 外部变量
               
          问题：函数声明与命名的函数表达式有什么区别？
5、执行环境与作用域：
          执行环境：execution context，定义了变量或函数有权访问的其他数据，从而决定了他们各自的行为。
               1、每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。代码中无法访问，但解析器在处理数据时会在后台使用它
               2、全局环境是最外围的一个执行环境，根据宿主环境的不同，表示全局环境的对象也不同（web-window、nodejs-global）
               3、某个执行环境的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。   
               4、每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出。ECMAScript的执行流就是由这个机制控制
         作用域：
               1、当代码在某个执行环境中运行时，会创建由变量对象组成的作用域链（scope chain），这是为了保证对执行环境有权访问的所有变量和函数的有序访问。
               2、作用域链的前端，始终都是当前执行代码所在环境的变量对象，如果这个环境是函数产生的，则函数的活动对象即为环境的变量对象（activation object），其最初只包含arguments对象（全局环境无此）
               3、作用域链中的下一个变量对象来自包含（外部）环境，这样一直延续下去至全局环境，全局执行环境始终是作用域链中的最后一个对象。
               4、作用域链保存在函数内部的[[Scope]]属性中，函数未被调用时其不包含函数的活动对象，函数定义的时候就已确定其作用域链的外部部分，调用时再添加活动对象至作用域链！
         延长作用域链：
               1、with(){}：将指定的对象添加到作用域链的前端
                              
               2、try-catch语句的catch块：不能很好的说明（可忽略！）
                              
          循环引用：
               1、循环引用指的是对象A包含了一个指向对象B的指针，而对象B中也包含了指向对象A的引用。
6、闭包：
          1、闭包是指有权访问另一个函数作用域中的变量的函数。
          2、在另一个函数内部定义的函数会将包含函数（外部函数）的活动对象添加到自己的作用域链中
          3、外部函数执行完后，其执行环境及作用域链会被销毁，但活动对象不会被销毁，因为内部闭包的作用域链仍在引用这个活动对象，直至闭包被销毁后，外部函数的活动对象才会被销毁
          4、由于闭包会携带包含它的函数的作用域，所以比一般函数占用更多的内存。慎重使用闭包！     
          5、闭包副作用：即闭包只能取得包含函数中任何变量的最后一个值！
          6、this对象：匿名函数的执行环境具有全局性，因此this一般指向全局对象！
          7、函数被调用时会自动取得两个特殊变量：this和arguments，内部函数再搜索这两个变量时，只会搜索到其活动对象为止。
7、其他用途：
          模仿块级作用域：
          私有变量：
                    私有成员：JS的对象没有私有成员的概念，所有对象属性都是公有的，可以通过函数来定义私有变量。
                    特权方法：有权访问私有变量和私有函数的公有方法。有两种创建方法！
                               1、构造函数中定义特权方法：特权方法是通过对象实例来访问的，每个实例都有同样的方法 （构造函数模式）
                               2、原型上定义特权方法： 每个对象实例继承一样的特权方法（原型模式）
                    模块模式：module pattern 为单例创建私有变量和特权方法。singleton 单例指的是只有一个实例的对象（JS是以字面量的形式来创建单例对象的）
                                    即最终返回Object的单例对象。
                               应用场景：如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有 数据的方法，那么就可以使用模块模式
                    增强的模块模式：限制返回的单例对象必须是指定类型的实例

                    
                    



源码：https://github.com/Jaykin/advanced-js-demo
          
          
